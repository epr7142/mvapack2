## Copyright (C) 2013 University of Nebraska Board of Regents.
## Written by Bradley Worley <bradley.worley@huskers.unl.edu>.
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; If not, see <http://www.gnu.org/licenses/>.

## -*- texinfo -*-
## @anchor{reconstruct}
## @deftypefn {Function File} {@var{s} =} reconstruct (@var{T}, @var{ab})
## @deftypefnx {Function File} {[@var{s}, @var{f}] =} reconstruct (@var{T}, @var{ab}, @var{t})
## Reconstructs a spectrum @var{s} and (optionally) a FID @var{f} matrix from
## a CRAFT decomposition @var{T} (@xref{decompose}). Reconstruction of the
## spectrum from @var{T} permits the automatic removal of phase errors from
## all signals, resulting in a spectrum that requires no phase correction.
## However, reconstructed time-domain data will contain the phasing.
##
## The signal table @var{T} need not be generated by @ref{decompose}. Any
## real, three-column matrix @var{T} will do. Every row of @var{T} is expected
## to be a complex exponentially decaying sinusoid. The columns of @var{T} are
## expected to be the amplitudes, frequencies, widths and phases of the
## signals. More specifically:
##
## @code{T(:,1)}: Amplitude, in absolute units. @*
## @code{T(:,2)}: Frequency, in Hertz. @*
## @code{T(:,3)}: Linewidth, in Hertz. @*
## @code{T(:,4)}: Phase, in @math{[-1, 1]}.
##
## Alternatively, @var{T} may be an @var{M}-by-1 cell array, with each value
## equal to a signal table (matrix). In this case, a data matrix having @var{M}
## rows will be generated, with each observation a reconstruction based on the
## @var{m}-th signal table in the cell array.
## @end deftypefn

function [s, f] = reconstruct (T, ab, t)
  % check if the number of expected arguments was passed.
  if (!any(nargin == [2 : 3]) || !any(nargout == [1 : 2]))
    % print the usage statement.
    print_usage();
  end

  % check the signal table argument.
  if (iscell(T) && rows(T) >= 1 && columns(T) == 1)
    % set the number of data matrix rows.
    N = rows(T);
  elseif (ismatrix(T) && isreal(T) && columns(T) == 4)
    % set the number of data matrix rows.
    N = 1;
  else
    % invalid argument. throw an exception.
    error('reconstruct: signal table must be a matrix or cell array');
  end

  % check the frequency-domain abscissa argument.
  if (isvector(ab) && isreal(ab))
    % set the number of data matrix columns.
    Ks = length(ab);

    % reshape the frequency axis.
    ab = reshape(ab, 1, Ks);
  else
    % invalid argument. throw an exception.
    error('reconstruct: spectral abscissa must be a real vector.');
  end

  % check if a time axis argument was provided.
  if (nargin >= 3 && !isempty(t))
    % check the type of the time axis argument.
    if (!isvector(t) || !isreal(t))
      % invalid argument. throw an exception.
      error('reconstruct: time axis argument must be a real vector');
    end

    % reconstruct the time-domain signals as well.
    dofid = true;

    % set the number of data matrix columns.
    Kf = length(t);

    % reshape the time axis.
    t = reshape(t, 1, Kf);

    % initialize the output FID.
    f = zeros(N, Kf);
  else
    % do not reconstruct the time-domain signals.
    dofid = false;
  end

  % initialize the output spectrum.
  s = zeros(N, Ks);  

  % act based on the number of signal tables we have.
  if (iscell(T))
    % loop through the data matrix rows to reconstruct.
    for k = 1 : rows(T)
      % see if we are doing the FID too.
      if (dofid == true)
        % yes. reconstruct time and frequency data.
        [sk, fk] = reconstruct(T{k}, ab, t);

        % store the reconstructions.
        s(k, :) = sk;
        f(k, :) = fk;
      else
        % no. reconstruct only frequency data and store the reconstruction.
        sk = reconstruct(T{k}, ab);
        s(k, :) = sk;
      end
    end
  elseif (ismatrix(T))
    % loop through the signals to reconstruct.
    for k = 1 : rows(T)
      % extract the parameters.
      A = T(k, 1);
      freq = T(k, 2);
      width = T(k, 3);
      phi = T(k, 4);

      % get the decay rate in hz.
      rho = width; % / pi;

      % sum the current signal into the output spectrum.
      s += A ./ (rho + 2 .* pi .* i .* (ab - freq));

      % are we to reconstruct the time-domain vector?
      if (dofid == true)
        % sum the current signal into the output FID.
        f += A .* exp(2 .* pi .* i .* (freq .* t + phi) - rho .* t);
      end
    end
  end

  % see if we only reconstructed one observation.
  if (N == 1)
    % columnize the spectrum.
    s = reshape(s, Ks, 1);

    % time-domain too?
    if (dofid == true)
      % yes. columnize the FID.
      f = reshape(f, Kf, 1);
    end
  end
end

